<!doctype html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="Android,设计模式,安卓入门,安卓高级,前端,JavaScript,h5,css3,Jquery">
  <meta name="description" content="null">
  <meta name="author" content="DINSON">
 
 
<meta name="keywords" content="Lambda，Android,Android,设计模式,安卓入门,安卓高级,前端,JavaScript,h5,css3,Jquery">


  
  <title>Lambda 表达式在 Android 开发中的使用</title>
  

  <link rel="alternate" href="/atom.xml" title="Android - Dinson - 酸奶布丁 - 国家一级码农" type="application/atom+xml">
  <link rel="canonical" href="http://dinson.win/2017/07/01/17-07-01/index.html">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="//at.alicdn.com/t/font_8ce77jkwodt5ipb9.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-home"></i><a href="/index.html" class="aside-menu-link" title="酸奶布丁">酸奶布丁</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-all"></i><a href="/archives/index.html" class="aside-menu-link" title="时间印记">时间印记</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-tag"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标记">分类标记</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-python"></i><a href="http://dinson.win/Python/index.html" class="aside-menu-link" title="Python">Python</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-jinglingqiu"></i><a href="http://dinson.win/Pokemon/" class="aside-menu-link" title="口袋妖怪">口袋妖怪</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-me"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-rss"></i><a href="/atom.xml" class="aside-menu-link" title="RSS">RSS</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value="" autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-quxiao"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.jpg" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          Dinson
          
          <strong class="aside-avatar-STRONG">Android喵</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">面朝电脑--栀子花开</p>
      <ul class="aside-show-info" >
	  <li class="aside-show-item"><a href="https://github.com/DinsonCat" class="aside-show-link" target="_blank"><i class="aside-show-icon iconfont icon-github"></i></a></li>
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link"   target="_blank"><i class="aside-show-icon iconfont icon-wechat"></i></a>
          <div class="aside-show-outside aside-show-outside_1">
            <img class="aside-show-IMG aside-show-IMG_1" src="/img/weixin.png" alt="微信"  >
          </div>
        </li>
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link"   target="_blank"><i class="aside-show-icon iconfont icon-qq"></i></a>
          <div class="aside-show-outside">
            <img class="aside-show-IMG  " src="/img/qq.jpg"   alt="QQ">
          </div>
        </li>
		 
      </ul>
	
	 
    </div>
	
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">Lambda 表达式在 Android 开发中的使用</h1>
    <p class="post-meta">
      </span>
      
      <a href="/categories/Android嫡系/" class="post-categories">Android嫡系</a>
      
      
      <a href="/tags/Lambda/"" class="post-tags"><i class="post-tags-icon iconfont icon-waixingren"></i>Lambda</a>
      
	  
	  
		<span id="busuanzi_container_page_pv"  class="post-time"><i class="post-tags-icon iconfont icon-yuedu"></i>Views <span id="busuanzi_value_page_pv"></span> Times</span>
	  
	  
    </p>
    
  </header>
  <div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Lambda ,希腊字母 “λ” 的英文名称。没错，就是你高中数学老师口中的那个“兰布达”。在编程世界中，它是匿名函数的别名， Java 从 Java 8 开始引入 lambda 表达式。而 Android 开发者的世界里，直到 Android Studio 2.4 Preview 4 及其之后的版本里，lambda 表达式才得到完全的支持（在此之前需要使用 Jack 编译器或 retrolambda 等插件，详见链接）。新版本 Android Studio 使用向导详见 <a href="https://developer.android.google.cn/studio/write/java8-support.html" target="_blank" rel="external">《在 Android Studio 上使用 Java 8 新特性》</a>。</p>
<p>Oracle 官方推出的 lambda 教程开篇第一句就表扬了其对匿名内部类笨拙繁琐的代码的简化，然而，在各大 RxJava 教程下的评论中，最受吐槽的就是作者提供的示例代码用了 lambda 表达式，给阅读造成了很大的障碍。</p>
<p>所以，在这篇文章中，我会先讲解 lambda 表达式的作用和三种形式，之后提供一个在 Android Studio 便捷使用 lambda 的小技巧，然后说一说 lambda 表达式中比较重要的变量捕获概念，最后再讲一些使用 lambda 表达式前后的差异。</p>
</blockquote>
<a id="more"></a>
<!-- 这是　　缩进-->
<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>前面提到，lambda 是匿名函数的别名。简单来说，lambda 表达式是对匿名内部类的进一步简化。使用 lambda 表达式的前提是编译器可以准确的判断出你需要哪一个匿名内部类的哪一个方法。</p>
<p>我们最经常接触使用匿名内部类的行为是为 view 设置 OnClickListener ，这时你的代码是这样的：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener()&#123;</div><div class="line">	<span class="meta">@Override</span> <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>&#123;</div><div class="line">		doSomeWork();</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>使用匿名内部类，实现了对象名的隐匿；而匿名函数，则是对方法名的隐匿。所以当使用 lambda 表达式实现上述代码时，是这样的：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener( </div><div class="line">	<span class="function"><span class="params">(View v)</span> -&gt;</span> &#123;</div><div class="line">		doSomeWork();</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>看不懂？没关系,在这两个示例中，你只要理解，lambda 表达式不仅对对象名进行隐匿，更完成了方法名的隐匿，展示了一个接口抽象方法最有价值的两点：<strong>参数列表</strong>和<strong>具体实现</strong>。下面我会对 lambda 的各种形式进行列举。</p>
<h2 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h2><blockquote>
<p>在 Java 中，lambda 表达式共有三种形式：<strong>函数式接口</strong>、<strong>方法引用</strong>和<strong>构造器引用</strong>。其中，函数式接口形式是最基本的 lambda 形式，其余两种形式都是基于此形式进行拓展。</p>
</blockquote>
<p>PS：为了更好的展示使用 lambda 表达式前后的代码区别，本文将使用 lambda 表达式给引用赋值的形式作为实例展示，而不是常用的直接将 lambda 表达式传入方法之中。同时，举例也不一定具有实际意义。</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口是指<strong>有且只有一个</strong>抽象方法的接口，比如各种 Listener 接口和 Runnable 接口。lambda 表达式就是对这类接口的匿名内部类进行简化。基本形式如下：<br><strong>( 参数列表… ) -&gt; { 语句块… }</strong></p>
<p>下面以 Java 提供的 Comparator 接口来展示一个实例，该接口常用于排序比较：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;<span class="built_in">int</span> compare(T var1, T var2);&#125;</div><div class="line">Comparator&lt;<span class="built_in">String</span>&gt; comparator = <span class="keyword">new</span> Comparator&lt;<span class="built_in">String</span>&gt; ()&#123;</div><div class="line">	<span class="meta">@Override</span> public <span class="built_in">int</span> compare(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2) &#123;</div><div class="line">		doSomeWork();</div><div class="line">		<span class="keyword">return</span> result;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">Comparator&lt;<span class="built_in">String</span>&gt; comparator = (<span class="built_in">String</span> s1, <span class="built_in">String</span> s2) -&gt; &#123;</div><div class="line">	doSomeWork();</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>当编译器可以推导出具体的参数类型时，我们可以从参数列表中忽略参数类型，那么上面的代码就变成了：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;String&gt; comparator = ( <span class="built_in">s1</span> , <span class="built_in">s2</span> ) -&gt; &#123;</div><div class="line">	doSomeWork()<span class="comment">;</span></div><div class="line">	return result<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>当参数只有一个时，参数列表两侧的圆括号也可省略，比如 OnClickListener 接口可写成 ：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> <span class="title">OnClickListener</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">onClick</span>(<span class="params">View v</span>)</span>; &#125;</div><div class="line">OnClickListener listener = v -&gt; &#123; 语句块... &#125; ;</div></pre></td></tr></table></figure></p>
<p>然而，当方法没有传入参数的时候，则记得提供一对空括号假装自己是参数列表（雾），比如 Runnable 接口：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> <span class="title">Runnable</span> &#123; <span class="function"><span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>)</span>; &#125;</div><div class="line">Runnable runnable = () -&gt; &#123; 语句块... &#125; ;</div></pre></td></tr></table></figure></p>
<p>当语句块内的处理逻辑只有一句表达式时，其两侧的花括号也可省略，特别注意这句处理逻辑表达式后面也不带分号。比如这个关闭 activity 的点击方法：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">button</span><span class="selector-class">.setOnClickListener</span>( <span class="selector-tag">v</span> <span class="selector-tag">-</span>&gt; <span class="selector-tag">activity</span><span class="selector-class">.finish</span>() );</div></pre></td></tr></table></figure></p>
<p>同时，当只有一句去除花括号的表达式且接口方法需要返回值时，这个表达式不用（也不能）在表达式前加 return ，就可以当作返回语句。下面用 Java 的 Function 接口作为示例，这是一个用于转换类型的接口，在这里我们获取一个 User 对象的姓名字符串并返回：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> <span class="keyword">Function</span> <span class="title">&lt;T,</span> R&gt; &#123; R apply(T t); &#125;</div><div class="line"><span class="keyword">Function</span> <span class="title">&lt;User,</span> String&gt; <span class="keyword">function</span> <span class="title">=</span> new <span class="keyword">Function</span> <span class="title">&lt;User,</span> String&gt;()&#123;</div><div class="line">	@Override public String apply(User user) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="type">user.getName()</span>;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">Function</span> <span class="title">&lt;User,</span> String&gt; <span class="keyword">function</span> <span class="title">=</span> user -&gt; user.getName() ;</div></pre></td></tr></table></figure></p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>在介绍第一种形式的之前，我曾写道：函数式接口形式是最基本的 lambda 表达式形式，其余形式都是由其拓展而来。那么，现在来介绍第二种形式：方法引用形式。</p>
<p>当我们使用第一种 lambda 表达式的时候，进行逻辑实现的时候我们既可以自己实现一系列处理，也可以直接调用已经存在的方法，下面以 Java 的 Predicate 接口作为示例，此接口用来实现判断功能，我们来对字符串进行全面的判空操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; &#125;</div><div class="line">Predicate&lt;String&gt; predicate=</div><div class="line">	s -&gt; &#123;</div><div class="line">		<span class="comment">//用基本代码组合进行判断</span></div><div class="line">		<span class="keyword">return</span> s==<span class="keyword">null</span> || s.length()==<span class="number">0</span> ;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure></p>
<p>我们知道，TextUtils 的 isEmpty() 方法实现了上述功能，所以我们可以写作：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;<span class="built_in">String</span>&gt; predicate = s -&gt; TextUtils.isEmpty(s) ;</div></pre></td></tr></table></figure></p>
<p>这时我们调用了已存在的方法来进行逻辑判断，我们就可以使用方法引用的形式继续简化这一段 lambda 表达式：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Predicate<span class="params">&lt;String&gt;</span> predicate = <span class="symbol">TextUtils::</span>isEmpty ;</div></pre></td></tr></table></figure></p>
<p>惊不惊喜？意不意外？</p>
<p>方法引用形式就是<strong>当逻辑实现只有一句且调用了已存在的方法进行处理( this 和 super 的方法也可包括在内)时，对函数式接口形式的 lambda 表达式进行进一步的简化。</strong>传入引用方法的参数就是原接口方法的参数。</p>
<p>接下来总结一下方法引用形式的三种格式：</p>
<ol>
<li><p>object :: instanceMethod<br>直接调用任意对象的实例方法，如 obj::equals 代表调用 obj 的 equals 方法与接口方法参数比较是否相等，效果等同 obj.equals(t);。<br>当前类的方法可用this::method进行调用，父类方法同理。</p>
</li>
<li><p>ClassName :: staticMethod<br>直接调用某类的静态方法，并将接口方法参数传入，如上述 TextUtils::isEmpty ，效果等同 TextUtils.isEmpty(s);</p>
</li>
<li><p>ClassName :: instanceMethod<br>较为特殊,将接口方法参数列表的第一个参数作为方法调用者，其余参数作为方法参数。由于此类接口较少，故选择 Java 提供的 BiFunction 接口作为示例，该接口方法接收一个 T1 类对象和一个 T2 类对象，通过处理后返回 R 类对象：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> BiFunction&lt;T1, T2, R&gt; &#123;</div><div class="line">	R apply(T1 t1, T2 t2);</div><div class="line">&#125;</div><div class="line">BiFunction&lt;<span class="built_in">String</span>,<span class="built_in">String</span>,<span class="built_in">Boolean</span>&gt; biFunction=</div><div class="line">	<span class="keyword">new</span> BiFunction&lt;<span class="built_in">String</span>, <span class="built_in">String</span>, <span class="built_in">Boolean</span>&gt;() &#123;</div><div class="line">		<span class="meta">@Override</span> <span class="keyword">public</span> <span class="built_in">Boolean</span> apply(<span class="built_in">String</span> s1, <span class="built_in">String</span> s2)&#123;</div><div class="line">	        <span class="keyword">return</span> s1.equals(s2);</div><div class="line">	    &#125;</div><div class="line">    &#125;;</div><div class="line"><span class="comment">// ClassName 为接口方法的第一个参数的类名，同时利用接口方法的第一个参数作为方法调用者，其余参数作为方法参数，实现 s1.equals(s2);</span></div><div class="line">BiFunction&lt;<span class="built_in">String</span>,<span class="built_in">String</span>,<span class="built_in">Boolean</span>&gt; biFunction= <span class="built_in">String</span>::equals;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h3><p>Lambda 表达式的第三种形式，其实和方法引用十分相似，只不过方法名替换为 new 。其格式为<strong>ClassName :: new</strong>。这时编译器会通过上下文判断传入的参数的类型、顺序、数量等，来调用适合的构造器，返回对象。</p>
<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><p>Android Studio 会在可以转化为 lambda 表达式的代码上进行如图的灰色标识，这时将光标移至灰色区域，按下 Alt + Enter ，选择第一项（方法引用和构造器引用在第二项），IDE 就会自动进行转换。<br><img src="http://ondlsj2sn.bkt.clouddn.com/FjLLt5fswLsU3L2bFJNN_kYKGrVH.png" alt=""></p>
<h2 id="变量捕获"><a href="#变量捕获" class="headerlink" title="变量捕获"></a>变量捕获</h2><p>在使用匿名内部类时，若要在内部类中使用外部变量，则需要将此变量定义为 final 变量。因为我们并不知道所实现的接口方法何时会被调用，所以通过设立 final 来确保安全。在 lambda 表达式中，仍然需要遵守这个标准。</p>
<p>不过在 Java 8 中，新增了一个 effective final 功能，只要一个变量没有被修改过引用（基本变量则不能更改变量值），即为实质上的 final 变量，那么不用再在声明变量时加上 final 修饰符。接下来还是通过一个示例解释，示例中共有三句被注释掉的赋值语句，去除任意一句的注释，都会报错：Variable used in lambda expression should be final or effectively final。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> effectiveFinalInt=<span class="number">666</span>;<span class="comment">//外部变量</span></div><div class="line"><span class="comment">//①effectiveFinalInt=233；</span></div><div class="line"><span class="keyword">button</span>.setOnClickListener(v -&gt; &#123;</div><div class="line">	  Toast.makeText( effectiveFinalInt + <span class="string">""</span>).show();</div><div class="line">      <span class="comment">//②effectiveFinalInt=233;</span></div><div class="line">    &#125;);</div><div class="line">    </div><div class="line"><span class="comment">//③effectiveFinalInt=233;</span></div></pre></td></tr></table></figure></p>
<p>可以看到，我们可以不做任何声明上的改变即可在 lambda 中使用外部变量，前提是我们以 final 的规则对待这个变量。</p>
<h2 id="一点玄学"><a href="#一点玄学" class="headerlink" title="一点玄学"></a>一点玄学</h2><h3 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h3><p>在匿名内部类中，this 关键字指向的是匿名类本身的对象，而在 lambda 中，this 指向的是 lambda 表达式的外部类。</p>
<h3 id="方法数差异"><a href="#方法数差异" class="headerlink" title="方法数差异"></a>方法数差异</h3><p>当前 Android Studio 对 Java 8 新特性编译时采用脱糖（desugar）处理，lambda 表达式经过编译器编译后，每一个 lambda 表达式都会增加 1~2 个方法数。而 Android 应用的方法数不能超过 65536 个。虽然一般应用较难触发，但仍需注意。</p>
<p>参考资料</p>
<p>书籍：《 Java 核心技术 》</p>
<p>网络文章：<br><a href="https://developer.android.google.cn/studio/write/java8-support.html" target="_blank" rel="external">在 Android Studio 上使用 Java 8 新特性(官方)</a><br><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="external">Oracle 官方 lambda 教程</a><br><a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" target="_blank" rel="external">匿名函数–维基百科（需科学上网）</a><br><a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="external">深入浅出 Java 8 Lambda 表达式</a></p>
<!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> --></div>
    
      <p class="post-copyright">转载文章请链接上原文地址：<a class="post-copyright-link" href="http://dinson.win/2017/07/01/17-07-01/" title="http://dinson.win/2017/07/01/17-07-01/" target="_blank">http://dinson.win/2017/07/01/17-07-01/</a></p>

      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用"><span class="toc-text">作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#形式"><span class="toc-text">形式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数式接口"><span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法引用"><span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器引用"><span class="toc-text">构造器引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用技巧"><span class="toc-text">使用技巧</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量捕获"><span class="toc-text">变量捕获</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一点玄学"><span class="toc-text">一点玄学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-关键字"><span class="toc-text">this 关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法数差异"><span class="toc-text">方法数差异</span></a></li></ol></li></ol>
          </div>
        </div>
      </div>
    
  
  
 
</article>

      <footer class="footer">
  <p class="footer-text">© 2016 - 2017 ❤ Powered by - DINSON</p>
   
  <span id="busuanzi_container_site_pv"><i class="iconfont icon-dianji"></i>&nbsp;&nbsp;<span id="busuanzi_value_site_pv"></span>Times</span>
  <span style="margin: 0.5em 0.5em">|</span>
  <span id="busuanzi_container_site_uv"><i class="iconfont icon-fangke"></i>&nbsp;&nbsp;<span id="busuanzi_value_site_uv"></span>Times</span>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <p class="footer-text">一只穿着空气鞋碎花沙滩裤挂着大金链子叼着烟戴着墨镜翘着二郎腿边弹吉他边敲代码的程序猿</p>

  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</footer> 
    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
