<!doctype html>
<html lang="zh-CN">
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta content="yes" name="apple-mobile-web-app-capable">
  <meta content="black" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <meta name="keywords" content="Android,设计模式,安卓入门,安卓高级,前端,JavaScript,h5,css3,Jquery">
  <meta name="description" content="null">
  <meta name="author" content="DINSON">
 
 
<meta name="keywords" content="Python,基础,教学,Android,设计模式,安卓入门,安卓高级,前端,JavaScript,h5,css3,Jquery">


  
  <title>Python从入门到放弃（8）-- Socket</title>
  

  <link rel="alternate" href="/atom.xml" title="Android - Dinson - 酸奶布丁 - 国家一级码农" type="application/atom+xml">
  <link rel="canonical" href="http://dinson.win/2017/05/28/17-05-28/index.html">
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="//at.alicdn.com/t/font_8ce77jkwodt5ipb9.css">
</head>


  <body>
    <aside class="aside">
  <nav class="aside-menu">
    <ul class="aside-list">
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-home"></i><a href="/index.html" class="aside-menu-link" title="酸奶布丁">酸奶布丁</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-all"></i><a href="/archives/index.html" class="aside-menu-link" title="时间印记">时间印记</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-tag"></i><a href="/tags/index.html" class="aside-menu-link" title="分类标记">分类标记</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-python"></i><a href="http://dinson.win/Python/index.html" class="aside-menu-link" title="Python">Python</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-jinglingqiu"></i><a href="http://dinson.win/Pokemon/" class="aside-menu-link" title="口袋妖怪">口袋妖怪</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-me"></i><a href="/about/index.html" class="aside-menu-link" title="关于">关于</a></li>
        
      
        
        <li class="aside-item"><i class="aside-menu-icon iconfont icon-rss"></i><a href="/atom.xml" class="aside-menu-link" title="RSS">RSS</a></li>
        
      
    </ul>
  </nav>

  <article class="aside-show">
    
      <form class="search-from" id="search-from">
  <input class="search-text" id="search-text" type="text" name="searchText" value="" autocomplete="off">
  <button class="search-btn" id="search-btn" type="button"><i class="search-btn-icon iconfont icon-sousuo-sousuo"></i></button>
</form>

      <article class="search-data" id="search-data">
  <button class="search-close" id="search-close"><i class="search-close-icon iconfont icon-quxiao"></i></button>

  <div class="search-wrapper" id="search-wrapper"></div>
</article>

    
    <div class="aside-show-wrapper">
      <figure class="aside-avatar">
        <img src="/img/avatar.jpg" alt="avatar" class="aside-avatar-img">
        <figcaption class="aside-avatar-caption">
          Dinson
          
          <strong class="aside-avatar-STRONG">Android喵</strong>
          
        </figcaption>
      </figure>
      <p class="aside-show-description">面朝电脑--栀子花开</p>
      <ul class="aside-show-info" >
	  <li class="aside-show-item"><a href="https://github.com/DinsonCat" class="aside-show-link" target="_blank"><i class="aside-show-icon iconfont icon-github"></i></a></li>
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link"   target="_blank"><i class="aside-show-icon iconfont icon-wechat"></i></a>
          <div class="aside-show-outside aside-show-outside_1">
            <img class="aside-show-IMG aside-show-IMG_1" src="/img/weixin.png" alt="微信"  >
          </div>
        </li>
        <li class="aside-show-item">
          <a href="javascript: void(0);" class="aside-show-link"   target="_blank"><i class="aside-show-icon iconfont icon-qq"></i></a>
          <div class="aside-show-outside">
            <img class="aside-show-IMG  " src="/img/qq.jpg"   alt="QQ">
          </div>
        </li>
		 
      </ul>
	
	 
    </div>
	
  </article>
</aside>


    <article class="main" id="main">
      <article class="post min-height">
  
  <header class="post-header">
    
    <h1 class="post-title">Python从入门到放弃（8）-- Socket</h1>
    <p class="post-meta">
      </span>
      
      <a href="/categories/Python从入门到放弃/" class="post-categories">Python从入门到放弃</a>
      
      
	  
	  
		<span id="busuanzi_container_page_pv"  class="post-time"><i class="post-tags-icon iconfont icon-yuedu"></i>Views <span id="busuanzi_value_page_pv"></span> Times</span>
	  
	  
    </p>
    
  </header>
  <div class="post-content"><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
</blockquote>
<p>socket和file的区别：</p>
<ul>
<li>file模块是针对某个指定文件进行【打开】【读写】【关闭】</li>
<li>socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】</li>
</ul>
<a id="more"></a>
<!-- 这是　　缩进-->
<p><img src="http://ondlsj2sn.bkt.clouddn.com/Fo5Iac4x_-S14ZoClUX1d6DJ8JOg.png" alt=""></p>
<p><img src="http://ondlsj2sn.bkt.clouddn.com/FhHICNMLup6VgDnb1nJ6md2ktNOH.png" alt=""></p>
<p>socket server:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</div><div class="line"></div><div class="line">sk = socket.socket()</div><div class="line">sk.bind(ip_port)</div><div class="line">sk.<span class="built_in">listen</span>(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="built_in">while</span> True:</div><div class="line">    <span class="built_in">print</span> <span class="string">'server waiting...'</span></div><div class="line">    conn,addr = sk.accept()</div><div class="line"></div><div class="line">    client_data = conn.recv(<span class="number">1024</span>)</div><div class="line">    <span class="built_in">print</span> client_data</div><div class="line">    conn.sendall(<span class="string">'不要回答,不要回答,不要回答'</span>)</div><div class="line"></div><div class="line">    conn.<span class="built_in">close</span>()</div></pre></td></tr></table></figure></p>
<p>socket client:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</div><div class="line"></div><div class="line">sk = socket.socket()</div><div class="line">sk.<span class="built_in">connect</span>(ip_port)</div><div class="line"></div><div class="line">sk.sendall(<span class="string">'请求占领地球'</span>)</div><div class="line"></div><div class="line">server_reply = sk.recv(<span class="number">1024</span>)</div><div class="line"><span class="built_in">print</span> server_reply</div><div class="line"></div><div class="line">sk.<span class="built_in">close</span>()</div></pre></td></tr></table></figure></p>
<p>WEB服务应用：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">import <span class="built_in">socket</span></div><div class="line"> </div><div class="line">def handle_request(client):</div><div class="line">    buf = client.recv(<span class="number">1024</span>)</div><div class="line">    client.<span class="built_in">send</span>(<span class="string">"HTTP/1.1 200 OK\r\n\r\n"</span>)</div><div class="line">    client.<span class="built_in">send</span>(<span class="string">"Hello, World"</span>)</div><div class="line"> </div><div class="line">def main():</div><div class="line">    sock = <span class="built_in">socket</span>.<span class="built_in">socket</span>(<span class="built_in">socket</span>.AF_INET, <span class="built_in">socket</span>.SOCK_STREAM)</div><div class="line">    sock.bind((<span class="string">'localhost'</span>,<span class="number">8080</span>))</div><div class="line">    sock.listen(<span class="number">5</span>)</div><div class="line"> </div><div class="line">    <span class="keyword">while</span> True:</div><div class="line">        connection, address = sock.accept()</div><div class="line">        handle_request(connection)</div><div class="line">        connection.<span class="built_in">close</span>()</div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">  main()</div></pre></td></tr></table></figure></p>
<h2 id="Socket-参数介绍"><a href="#Socket-参数介绍" class="headerlink" title="Socket 参数介绍"></a>Socket 参数介绍</h2><p><code>sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)</code></p>
<ul>
<li><p>参数一：地址簇<br>　　<code>socket.AF_INET</code> IPv4（默认）<br>　　<code>socket.AF_INET6</code> IPv6<br>　　<code>socket.AF_UNIX</code> 只能够用于单一的Unix系统进程间通信</p>
</li>
<li><p>参数二：类型<br>　　<code>socket.SOCK_STREAM</code>　　流式socket , for TCP （默认）<br>　　<code>socket.SOCK_DGRAM</code>　　 数据报式socket , for UDP<br>　　<code>socket.SOCK_RAW</code> 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。<br>　　<code>socket.SOCK_RDM</code> 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。<br>　　<code>socket.SOCK_SEQPACKET</code> 可靠的连续数据包服务</p>
</li>
<li><p>参数三：协议<br>　　<code>0</code>　　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议</p>
</li>
</ul>
<p><code>sk.bind(address)</code><br>　　s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p>
<p><code>sk.listen(backlog)</code><br>　　开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。<br>　　backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5这个值不能无限大，因为要在内核中维护连接队列</p>
<p><code>sk.setblocking(bool)</code><br>　　是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。</p>
<p><code>sk.accept()</code><br>　　接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。<br>　　接收TCP 客户的连接（阻塞式）等待连接的到来</p>
<p><code>sk.connect(address)</code><br>　　连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p>
<p><code>sk.connect_ex(address)</code><br>　　同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061</p>
<p><code>sk.close()</code><br>　　关闭套接字</p>
<p><code>sk.recv(bufsize[,flag])</code><br>　　接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p>
<p><code>sk.recvfrom(bufsize[.flag])</code><br>　　与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</p>
<p><code>sk.send(string[,flag])</code><br>　　将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p>
<p><code>sk.sendall(string[,flag])</code><br>　　将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。<br>　　内部通过递归调用send，将所有内容发送出去。</p>
<p><code>sk.sendto(string[,flag],address)</code><br>　　将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。</p>
<p><code>sk.settimeout(timeout)</code><br>　　设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）</p>
<p><code>sk.getpeername()</code><br>　　返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</p>
<p><code>sk.getsockname()</code><br>　　返回套接字自己的地址。通常是一个元组(ipaddr,port)</p>
<p><code>sk.fileno()</code><br>　　套接字的文件描述符</p>
<h2 id="实例：智能机器人"><a href="#实例：智能机器人" class="headerlink" title="实例：智能机器人"></a>实例：智能机器人</h2><p>服务端:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</div><div class="line">sk = socket.socket()</div><div class="line">sk.bind(ip_port)</div><div class="line">sk.listen(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="literal">True</span>:</div><div class="line">    conn,address =  sk.accept()</div><div class="line">    conn.sendall(<span class="string">'欢迎致电 10086，请输入1xxx,0转人工服务.'</span>)</div><div class="line">    Flag = <span class="literal">True</span></div><div class="line">    <span class="keyword">while</span> Flag:</div><div class="line">        <span class="built_in">data</span> = conn.recv(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> <span class="built_in">data</span> == <span class="string">'exit'</span>:</div><div class="line">            Flag = <span class="literal">False</span></div><div class="line">        elif <span class="built_in">data</span> == <span class="string">'0'</span>:</div><div class="line">            conn.sendall(<span class="string">'通过可能会被录音.balabala一大推'</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            conn.sendall(<span class="string">'请重新输入.'</span>)</div><div class="line">    conn.close()</div></pre></td></tr></table></figure></p>
<p>客户端:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"></div><div class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">8005</span>)</div><div class="line">sk = socket.socket()</div><div class="line">sk.<span class="built_in">connect</span>(ip_port)</div><div class="line">sk.settimeout(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="built_in">while</span> True:</div><div class="line">    data = sk.recv(<span class="number">1024</span>)</div><div class="line">    <span class="built_in">print</span> <span class="string">'receive:'</span>,data</div><div class="line">    inp = raw_input(<span class="string">'please input:'</span>)</div><div class="line">    sk.sendall(inp)</div><div class="line">    <span class="built_in">if</span> inp == <span class="string">'exit'</span>:</div><div class="line">        <span class="built_in">break</span></div><div class="line"></div><div class="line">sk.<span class="built_in">close</span>()</div></pre></td></tr></table></figure></p>
<h2 id="SocketServer模块"><a href="#SocketServer模块" class="headerlink" title="SocketServer模块"></a>SocketServer模块</h2><blockquote>
<p>SocketServer内部使用 IO多路复用 以及 “多线程” 和 “多进程” ，从而实现并发处理多个客户端请求的Socket服务端。即：每个客户端请求连接到服务器时，Socket服务端都会在服务器是创建一个“线程”或者“进程” 专门负责处理当前客户端的所有请求。</p>
</blockquote>
<p><img src="http://ondlsj2sn.bkt.clouddn.com/FuemAEvM1JPr0JK8a8gAeeaXOdr8.png" alt=""></p>
<p>让你的socketserver并发起来， 必须选择使用以下一个多并发的类<br><strong>class socketserver.ForkingTCPServer</strong><br><strong>class socketserver.ForkingUDPServer</strong><br><strong>class socketserver.ThreadingTCPServer</strong><br><strong>class socketserver.ThreadingUDPServer</strong></p>
<h2 id="ThreadingTCPServer"><a href="#ThreadingTCPServer" class="headerlink" title="ThreadingTCPServer"></a>ThreadingTCPServer</h2><blockquote>
<p>ThreadingTCPServer实现的Soket服务器内部会为每个client创建一个 “<code>线程</code>”，该线程用来和客户端进行交互。</p>
</blockquote>
<h3 id="ThreadingTCPServer基础"><a href="#ThreadingTCPServer基础" class="headerlink" title="ThreadingTCPServer基础"></a>ThreadingTCPServer基础</h3><p>使用ThreadingTCPServer:</p>
<ul>
<li>创建一个继承自 SocketServer.BaseRequestHandler 的类</li>
<li>类中必须定义一个名称为 handle 的方法</li>
<li>启动ThreadingTCPServer</li>
</ul>
<h3 id="ThreadingTCPServer源码剖析"><a href="#ThreadingTCPServer源码剖析" class="headerlink" title="ThreadingTCPServer源码剖析"></a>ThreadingTCPServer源码剖析</h3><p>ThreadingTCPServer的类图关系如下：<br><img src="http://ondlsj2sn.bkt.clouddn.com/Fmp-X1BHrn_A3vo68eGw6izBVHfs.png" alt=""></p>
<p>内部调用流程为：</p>
<ul>
<li>启动服务端程序</li>
<li>执行 TCPServer.<strong>init</strong> 方法，创建服务端Socket对象并绑定 IP 和 端口</li>
<li>执行 BaseServer.<strong>init</strong> 方法，将自定义的继承自SocketServer.BaseRequestHandler 的类 MyRequestHandle赋值给self.RequestHandlerClass</li>
<li>执行 BaseServer.server_forever 方法，While 循环一直监听是否有客户端请求到达 …<br>当客户端连接到达服务器</li>
<li>执行 ThreadingMixIn.process_request 方法，创建一个 “线程” 用来处理请求</li>
<li>执行 ThreadingMixIn.process_request_thread 方法</li>
<li>执行 BaseServer.finish_request 方法，执行 self.RequestHandlerClass()  即：执行 自定义 MyRequestHandler 的构造方法（自动调用基类BaseRequestHandler的构造方法，在该构造方法中又会调用 MyRequestHandler的handle方法）</li>
</ul>
<h3 id="精简代码"><a href="#精简代码" class="headerlink" title="精简代码"></a>精简代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> socket</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> select</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(request, client_address)</span>:</span></div><div class="line">    <span class="keyword">print</span> request,client_address</div><div class="line">    conn = request</div><div class="line">    conn.sendall(<span class="string">'欢迎致电 10086，请输入1xxx,0转人工服务.'</span>)</div><div class="line">    flag = <span class="keyword">True</span></div><div class="line">    <span class="keyword">while</span> flag:</div><div class="line">        data = conn.recv(<span class="number">1024</span>)</div><div class="line">        <span class="keyword">if</span> data == <span class="string">'exit'</span>:</div><div class="line">            flag = <span class="keyword">False</span></div><div class="line">        <span class="keyword">elif</span> data == <span class="string">'0'</span>:</div><div class="line">            conn.sendall(<span class="string">'通过可能会被录音.balabala一大推'</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            conn.sendall(<span class="string">'请重新输入.'</span>)</div><div class="line"></div><div class="line">sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</div><div class="line">sk.bind((<span class="string">'127.0.0.1'</span>,<span class="number">8002</span>))</div><div class="line">sk.listen(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">    r, w, e = select.select([sk,],[],[],<span class="number">1</span>)</div><div class="line">    <span class="keyword">print</span> <span class="string">'looping'</span></div><div class="line">    <span class="keyword">if</span> sk <span class="keyword">in</span> r:</div><div class="line">        <span class="keyword">print</span> <span class="string">'get request'</span></div><div class="line">        request, client_address = sk.accept()</div><div class="line">        t = threading.Thread(target=process, args=(request, client_address))</div><div class="line">        t.daemon = <span class="keyword">False</span></div><div class="line">        t.start()</div><div class="line"></div><div class="line">sk.close()</div></pre></td></tr></table></figure>
<p>如精简代码可以看出，SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 select 和 Threading 两个东西，其实本质上就是在服务器端为每一个客户端创建一个线程，当前线程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p>
<h2 id="ForkingTCPServer"><a href="#ForkingTCPServer" class="headerlink" title="ForkingTCPServer"></a>ForkingTCPServer</h2><blockquote>
<p>ForkingTCPServer和ThreadingTCPServer的使用和执行流程基本一致，只不过在内部分别为请求者建立 “线程”  和 “进程”。</p>
</blockquote>
<p>服务端:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> SocketServer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(SocketServer.BaseRequestHandler)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># print self.request,self.client_address,self.server</span></div><div class="line">        conn = self.request</div><div class="line">        conn.sendall(<span class="string">'欢迎致电 10086，请输入1xxx,0转人工服务.'</span>)</div><div class="line">        Flag = <span class="keyword">True</span></div><div class="line">        <span class="keyword">while</span> Flag:</div><div class="line">            data = conn.recv(<span class="number">1024</span>)</div><div class="line">            <span class="keyword">if</span> data == <span class="string">'exit'</span>:</div><div class="line">                Flag = <span class="keyword">False</span></div><div class="line">            <span class="keyword">elif</span> data == <span class="string">'0'</span>:</div><div class="line">                conn.sendall(<span class="string">'通过可能会被录音.balabala一大推'</span>)</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                conn.sendall(<span class="string">'请重新输入.'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    server = SocketServer.ForkingTCPServer((<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>),MyServer)</div><div class="line">    server.serve_forever()</div></pre></td></tr></table></figure></p>
<p>客户端<br><figure class="highlight tcl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line">import <span class="keyword">socket</span></div><div class="line"></div><div class="line"></div><div class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">8009</span>)</div><div class="line">sk = <span class="keyword">socket</span>.<span class="keyword">socket</span>()</div><div class="line">sk.connect(ip_port)</div><div class="line">sk.settimeout(<span class="number">5</span>)</div><div class="line"></div><div class="line"><span class="keyword">while</span> True:</div><div class="line">    data = sk.recv(<span class="number">1024</span>)</div><div class="line">    print <span class="string">'receive:'</span>,data</div><div class="line">    inp = raw_input(<span class="string">'please input:'</span>)</div><div class="line">    sk.sendall(inp)</div><div class="line">    <span class="keyword">if</span> inp == <span class="string">'exit'</span>:</div><div class="line">        <span class="keyword">break</span></div><div class="line"></div><div class="line">sk.<span class="keyword">close</span>()</div></pre></td></tr></table></figure></p>
<p>以上ForkingTCPServer只是将 ThreadingTCPServer 实例中的代码：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server = SocketServer.ThreadingTCPServer(('<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>',<span class="number">8009</span>),MyRequestHandler)</div></pre></td></tr></table></figure></p>
<p>变更为：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">server = SocketServer.ForkingTCPServer(('<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>',<span class="number">8009</span>),MyRequestHandler)</div></pre></td></tr></table></figure></p>
<p>SocketServer的ThreadingTCPServer之所以可以同时处理请求得益于 select 和 os.fork 两个东西，其实本质上就是在服务器端为每一个客户端创建一个进程，当前新创建的进程用来处理对应客户端的请求，所以，可以支持同时n个客户端链接（长连接）。</p>
<h2 id="Twisted"><a href="#Twisted" class="headerlink" title="Twisted"></a>Twisted</h2><blockquote>
<p>Twisted是一个事件驱动的网络框架，其中包含了诸多功能，例如：网络协议、线程、数据库管理、网络操作、电子邮件等。</p>
</blockquote>
<p><img src="http://ondlsj2sn.bkt.clouddn.com/FiTgejJLUMWQUgOBhOrcmE9XBth0.png" alt=""></p>
<h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>简而言之，事件驱动分为二个部分：第一，注册事件；第二，触发事件。</p>
<p>自定义事件驱动框架，命名为：“弑君者”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># event_drive.py</div><div class="line"></div><div class="line">event_list = []</div><div class="line"></div><div class="line"></div><div class="line">def run():</div><div class="line">    for event in event_list:</div><div class="line">        obj = event()</div><div class="line">        obj.execute()</div><div class="line"></div><div class="line"></div><div class="line">class BaseHandler(object):</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    用户必须继承该类，从而规范所有类的方法（类似于接口的功能）</div><div class="line">    &quot;&quot;&quot;</div><div class="line">    def execute(self):</div><div class="line">        raise Exception(&apos;you must overwrite execute&apos;)</div></pre></td></tr></table></figure></p>
<p>程序员使用“弑君者框架”：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> source <span class="keyword">import</span> event_drive</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span><span class="params">(event_drive.BaseHandler)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'event-drive execute MyHandler'</span></div><div class="line"></div><div class="line">event_drive.event_list.append(MyHandler)</div><div class="line">event_drive.run()</div></pre></td></tr></table></figure></p>
<p>如上述代码，事件驱动只不过是框架规定了执行顺序，程序员在使用框架时，可以向原执行顺序中注册“事件”，从而在框架执行时可以出发已注册的“事件”。</p>
<h3 id="基于事件驱动Socket"><a href="#基于事件驱动Socket" class="headerlink" title="基于事件驱动Socket"></a>基于事件驱动Socket</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> protocol</div><div class="line"><span class="keyword">from</span> twisted.internet <span class="keyword">import</span> reactor</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Echo</span><span class="params">(protocol.Protocol)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dataReceived</span><span class="params">(self, data)</span>:</span></div><div class="line">        self.transport.write(data)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    factory = protocol.ServerFactory()</div><div class="line">    factory.protocol = Echo</div><div class="line"> </div><div class="line">    reactor.listenTCP(<span class="number">8000</span>,factory)</div><div class="line">    reactor.run()</div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p><img src="http://ondlsj2sn.bkt.clouddn.com/FnxqehwDO753xD7SpFAFZwDgdIyM.png" alt=""></p>
<p>程序执行流程：</p>
<ul>
<li>运行服务端程序</li>
<li>创建Protocol的派生类Echo</li>
<li>创建ServerFactory对象，并将Echo类封装到其protocol字段中</li>
<li>执行reactor的 listenTCP 方法，内部使用 tcp.Port 创建socket server对象，并将该对象添加到了 reactor的set类型的字段 _read 中</li>
<li>执行reactor的 run 方法，内部执行 while 循环，并通过 select 来监视 _read 中文件描述符是否有变化，循环中…</li>
<li>客户端请求到达</li>
<li>执行reactor的 _doReadOrWrite 方法，其内部通过反射调用 tcp.Port 类的 doRead 方法，内部 accept 客户端连接并创建Server对象实例（用于封装客户端socket信息）和 创建 Echo 对象实例（用于处理请求） ，然后调用 Echo 对象实例的 makeConnection 方法，创建连接。</li>
<li>执行 tcp.Server 类的 doRead 方法，读取数据，</li>
<li>执行 tcp.Server 类的 _dataReceived 方法，如果读取数据内容为空（关闭链接），否则，出发 Echo 的 dataReceived 方法</li>
<li>执行 Echo 的 dataReceived 方法 </li>
</ul>
<!-- <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=100% height=86 src="//music.163.com/outchain/player?type=2&id=songid&auto=1&height=66"></iframe> --></div>
    
      <p class="post-copyright">转载文章请链接上原文地址：<a class="post-copyright-link" href="http://dinson.win/2017/05/28/17-05-28/" title="http://dinson.win/2017/05/28/17-05-28/" target="_blank">http://dinson.win/2017/05/28/17-05-28/</a></p>

      
      <div class="toc-wrapper">
        <div class="toc-scroll">
          <div class="toc-middle">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概述"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Socket-参数介绍"><span class="toc-text">Socket 参数介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例：智能机器人"><span class="toc-text">实例：智能机器人</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SocketServer模块"><span class="toc-text">SocketServer模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadingTCPServer"><span class="toc-text">ThreadingTCPServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadingTCPServer基础"><span class="toc-text">ThreadingTCPServer基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadingTCPServer源码剖析"><span class="toc-text">ThreadingTCPServer源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#精简代码"><span class="toc-text">精简代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ForkingTCPServer"><span class="toc-text">ForkingTCPServer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Twisted"><span class="toc-text">Twisted</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事件驱动"><span class="toc-text">事件驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于事件驱动Socket"><span class="toc-text">基于事件驱动Socket</span></a></li></ol></li></ol>
          </div>
        </div>
      </div>
    
  
  
 
</article>

      <footer class="footer">
  <p class="footer-text">© 2016 - 2017 ❤ Powered by - DINSON</p>
   
  <span id="busuanzi_container_site_pv"><i class="iconfont icon-dianji"></i>&nbsp;&nbsp;<span id="busuanzi_value_site_pv"></span>Times</span>
  <span style="margin: 0.5em 0.5em">|</span>
  <span id="busuanzi_container_site_uv"><i class="iconfont icon-fangke"></i>&nbsp;&nbsp;<span id="busuanzi_value_site_uv"></span>Times</span>
  <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  <p class="footer-text">一只穿着空气鞋碎花沙滩裤挂着大金链子叼着烟戴着墨镜翘着二郎腿边弹吉他边敲代码的程序猿</p>

  <script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

</footer> 
    </article>

    <script src="/js/to-top.js"></script>
    <script src="/js/search.js"></script>
  </body>
</html>
